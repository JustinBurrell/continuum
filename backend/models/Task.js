const mongoose = require('mongoose');

// ============================================================
// TASK SCHEMA
// Purpose: Define the structure of a Task document in MongoDB
// Collection: tasks
// Features: Task management, calendar integration, scheduling,
//           recurrence, group tasks, linked notes
// ============================================================
const taskSchema = new mongoose.Schema({
    /**
     * Ownership
     * Purpose: Link the task to the user who created it
     * Fields: userId
     */
    userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true,
        index: true,
    },

    /**
     * Content
     * Purpose: Store the task's title and description
     * Fields: title, description
     */
    title: {
        type: String,
        maxlength: 200,
    },
    description: {
        type: String,
        maxlength: 2000,
    },

    /**
     * Linked Note
     * Purpose: Optionally link a task to a note (e.g. "study this note")
     * Fields: noteId
     */
    noteId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Note',
        index: true,
        default: null,
    },

    /**
     * Scheduling
     * Purpose: Track when the task is due, how long it takes, and when to remind
     * Fields: dueDate, duration, reminderMinutes
     */
    dueDate: {
        type: Date,
        index: true,
        required: true,
    },
    duration: {
        type: Number,
        default: 60,
    },
    reminderMinutes: {
        type: Number,
        default: 30,
    },

    /**
     * Categorization
     * Purpose: Classify the task by type, priority, and current status
     * Fields: type, priority, status
     */
    type: {
        type: String,
        enum: ['homework', 'study', 'project', 'exam', 'other'],
        index: true,
    },
    priority: {
        type: String,
        enum: ['low', 'medium', 'high'],
        index: true,
    },
    status: {
        type: String,
        enum: ['todo', 'in_progress', 'completed'],
        default: 'todo',
        index: true,
    },

    /**
     * Recurrence
     * Purpose: Define repeating task rules (daily, weekly, monthly)
     * Fields: recurrence.frequency, interval, daysOfWeek, endDate, parentTaskId
     */
    recurrence: {
        frequency: {
            type: String,
            enum: ['none', 'daily', 'weekly', 'monthly'],
        },
        interval: {
            type: Number,
            default: 1,
        },
        daysOfWeek: [{
            type: Number,
        }],
        endDate: {
            type: Date,
            default: null,
        },
        parentTaskId: {
            type: mongoose.Schema.Types.ObjectId,
            default: null,
        },
    },

    /**
     * Collaboration
     * Purpose: Support shared/group tasks with per-participant status tracking
     * Fields: isShared, participants[].userId, status, completedAt
     */
    isShared: {
        type: Boolean,
        default: false,
        index: true,
    },
    participants: [{
        userId: {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'User',
        },
        status: {
            type: String,
            enum: ['todo', 'in_progress', 'completed'],
            default: 'todo',
        },
        completedAt: {
            type: Date,
        },
    }],

    /**
     * Metadata
     * Purpose: Track completion and soft deletes
     * Fields: completedAt, deletedAt
     * Note: createdAt/updatedAt are auto-generated by timestamps option
     */
    completedAt: {
        type: Date,
    },
    deletedAt: {
        type: Date,
        default: null,
    },
}, {
    timestamps: true,
});

// ============================================================
// INDEXES
// Purpose: Speed up common queries by telling MongoDB which fields to pre-sort
// These compound indexes optimize queries that filter by BOTH fields at once
// ============================================================
taskSchema.index({ userId: 1, deletedAt: 1, dueDate: 1 });   // "get my tasks by due date"
taskSchema.index({ userId: 1, status: 1, dueDate: 1 });       // "get my incomplete tasks by due date"
taskSchema.index({ 'participants.userId': 1, isShared: 1 });   // "get shared tasks I'm participating in"
taskSchema.index({ dueDate: 1, status: 1 });                   // "find overdue tasks across all users"

// ============================================================
// PRE-SAVE HOOK
// Purpose: Runs automatically BEFORE a document is saved to the database
// Use: Set completedAt timestamp when status changes to 'completed'
//      If task has recurrence, generate the next occurrence
// When it runs: Every time .save() is called — but only acts if status changed
// ============================================================
taskSchema.pre('save', async function (next) {
    // Only run if status was actually changed (skip on title updates, etc.)
    if (!this.isModified('status')) return next();

    // Auto-set completedAt based on status change
    if (this.status === 'completed') {
        // Task was just marked complete — stamp the time
        this.completedAt = new Date();
    } else {
        // Task was reopened (e.g. completed → todo) — clear the timestamp
        this.completedAt = null;
    }

    // Generate next occurrence for recurring tasks
    // Only runs when a recurring task is completed
    if (this.status === 'completed' && this.recurrence?.frequency && this.recurrence.frequency !== 'none') {
        // Calculate the next due date based on frequency
        const nextDueDate = new Date(this.dueDate);

        switch (this.recurrence.frequency) {
            case 'daily':
                nextDueDate.setDate(nextDueDate.getDate() + this.recurrence.interval);
                break;
            case 'weekly':
                nextDueDate.setDate(nextDueDate.getDate() + (7 * this.recurrence.interval));
                break;
            case 'monthly':
                nextDueDate.setMonth(nextDueDate.getMonth() + this.recurrence.interval);
                break;
        }

        // Check if the next occurrence is past the end date (if one is set)
        if (!this.recurrence.endDate || nextDueDate <= this.recurrence.endDate) {
            // Get the Task model from mongoose (can't use require inside a hook)
            const Task = mongoose.model('Task');

            // Create the next occurrence as a new task
            await Task.create({
                userId: this.userId,
                title: this.title,
                description: this.description,
                noteId: this.noteId,
                dueDate: nextDueDate,
                duration: this.duration,
                reminderMinutes: this.reminderMinutes,
                type: this.type,
                priority: this.priority,
                status: 'todo',
                recurrence: {
                    frequency: this.recurrence.frequency,
                    interval: this.recurrence.interval,
                    daysOfWeek: this.recurrence.daysOfWeek,
                    endDate: this.recurrence.endDate,
                    parentTaskId: this.recurrence.parentTaskId || this._id,
                },
                isShared: this.isShared,
                participants: this.participants?.map(p => ({
                    userId: p.userId,
                    status: 'todo',
                    completedAt: null,
                })),
            });
        }
    }
    next();
});

// ============================================================
// VIRTUALS
// Purpose: Computed properties that DON'T get stored in the database
// They're calculated on-the-fly when you access them (like a getter)
// ============================================================

/**
 * isOverdue
 * Purpose: Check if the task is past due and not yet completed
 * Usage: task.isOverdue → true/false
 */
taskSchema.virtual('isOverdue').get(function () {
    return this.status !== 'completed' && this.dueDate < new Date();
});

module.exports = mongoose.model('Task', taskSchema);
