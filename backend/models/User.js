const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');

// ============================================================
// USER SCHEMA
// Purpose: Define the structure of a User document in MongoDB
// Collection: users
// Features: Authentication (email/password + Google OAuth), profiles,
//           password reset, user preferences, soft deletes
// ============================================================
const userSchema = new mongoose.Schema({
    /**
     * Authentication
     * Purpose: Store login credentials and identify users
     * Fields: email, username, password
     * Note: createdAt/updatedAt are auto-generated by timestamps option at the bottom
     */
    email: {
        type: String,
        required: [true, 'Email is required'],
        unique: true,
        lowercase: true,
        trim: true,
    },
    username: {
        type: String,
        required: [true, 'Username is required'],
        unique: true,
        trim: true,
    },
    password: {
        type: String,
        required: [true, 'Password is required'],
        minlength: [8, 'Password must be at least 8 characters'],
        validate: {
            validator: function (value) {
                return /^(?=.*[a-zA-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?])/.test(value);
            },
            message: 'Password must contain at least one letter, one number, and one special character',
        },
        select: false,
    },

    /**
     * Profile
     * Purpose: Store user display info and personal details
     * Fields: firstName, lastName, avatarUrl, bio
     */
    firstName: {
        type: String,
        required: [true, 'First Name is required'],
        trim: true,
    },
    lastName: {
        type: String,
        required: [true, 'Last Name is required'],
        trim: true,
    },
    avatarUrl: {
        type: String,
    },
    bio: {
        type: String,
    },

    /**
     * Google OAuth
     * Purpose: Store Google account link for Drive/Docs API access
     * Fields: googleId, googleAccessToken, googleRefreshToken, googleTokenExpiry
     */
    googleId: {
        type: String,
        sparse: true,
        unique: true,
    },
    googleAccessToken: {
        type: String,
        select: false,
    },
    googleRefreshToken: {
        type: String,
        select: false,
    },
    googleTokenExpiry: {
        type: Date,
    },

    /**
     * Password Reset
     * Purpose: Store temporary token and expiry for forgot-password flow
     * Fields: passwordResetToken, passwordResetExpires
     */

    passwordResetToken: {
        type: String,
        select: false,
    },
    passwordResetExpires: {
        type: Date,
    },

    /**
     * Settings
     * Purpose: Store user preferences (embedded — small, always needed with user)
     * Fields: emailNotifications, pushNotifications
     * Note: email/push notifications are schema-ready but not implemented yet. MVP uses in-app notifications only
     * Note: note privacy (private/friends) is set per-note on the Note model, not globally here
     */
    settings: {
        emailNotifications: {
            type: Boolean,
            default: true,
        },
        pushNotifications: {
            type: Boolean,
            default: true,
        },
    },

    /**
     * Metadata      
     * Purpose: Track account status, login activity, and soft deletes
     * Fields: lastLoginAt, emailVerified, deletedAt
     */
    lastLoginAt: {
        type: Date,
    },
    emailVerified: {
        type: Boolean,
        default: false,
    },
    deletedAt: {
        type: Date,
        default: null,
    },
}, {
    timestamps: true, // auto-creates createdAt and updatedAt on every document
});

// ============================================================
// INDEXES
// Purpose: Speed up common queries by telling MongoDB which fields to pre-sort
// Note: unique fields (email, username, googleId) already have indexes from the schema
// These compound indexes optimize queries that filter by BOTH fields at once
// ============================================================
userSchema.index({ email: 1, deletedAt: 1 });
userSchema.index({ username: 1, deletedAt: 1 });
// googleId index already created by sparse: true + unique: true in schema

// ============================================================
// PRE-SAVE HOOK
// Purpose: Runs automatically BEFORE a document is saved to the database
// Use: Hash the password so we never store plain text passwords
// When it runs: Every time .save() is called — but we only hash if password changed
// Requires: bcryptjs package (npm install bcryptjs)
// ============================================================
userSchema.pre('save', async function () {
    // Only hash if password was changed (skip on profile updates, etc.)
    if (!this.isModified('password')) return;

    // Generate a salt (random string added to password before hashing)
    const salt = await bcrypt.genSalt(12);

    // Hash the plain text password with the salt
    this.password = await bcrypt.hash(this.password, salt);
});

// ============================================================
// METHODS
// Purpose: Functions you can call on a single user document (e.g. user.comparePassword())
// These are instance methods they have access to `this` (the user document)
// ============================================================

/**
 * comparePassword
 * Purpose: Check if a login attempt password matches the stored hashed password
 * Used in: Login route after finding user by email, verify their password
 * Requires: bcryptjs
 * @param {String} candidatePassword - The plain text password from the login form
 * @returns {Boolean} - true if passwords match, false if not
 */
userSchema.methods.comparePassword = async function (candidatePassword) {
    // bcrypt.compare hashes candidatePassword the same way and checks if it matches
    return await bcrypt.compare(candidatePassword, this.password);
};

/**
 * createPasswordResetToken
 * Purpose: Generate a random token for the forgot-password email link
 * Used in: Forgot password route creates token, saves to user, sends via email
 * Requires: crypto (built-in Node.js module, no install needed)
 * @returns {String} - The unhashed token (sent in email). Hashed version stored in DB.
 */
userSchema.methods.createPasswordResetToken = function () {
    // Generate a random 32-byte token and convert to a hex string
    // This produces something like "a3f8b2c1d4e5..." (64 characters)
    const resetToken = crypto.randomBytes(32).toString('hex');

    // Hash the token before storing in the database
    // Same idea as passwords — if the DB is compromised, the attacker can't use the hashed token
    // We use SHA-256 here (simpler/faster than bcrypt — reset tokens are already random)
    this.passwordResetToken = crypto.createHash('sha256').update(resetToken).digest('hex');

    // Set expiry to 1 hour from now
    // After 1 hour, this token is useless even if someone finds the email
    this.passwordResetExpires = Date.now() + 60 * 60 * 1000; // 60 min * 60 sec * 1000 ms

    // Return the UNHASHED token
    // This is what goes in the email link: /reset-password?token=a3f8b2c1d4e5...
    // When the user clicks the link, we hash their token again and compare to the DB
    return resetToken;
};

// ============================================================
// VIRTUALS
// Purpose: Computed properties that DON'T get stored in the database
// They're calculated on-the-fly when you access them (like a getter)
// ============================================================

/**
 * fullName
 * Purpose: Convenience — returns "Justin Burrell" instead of accessing firstName + lastName separately
 * Usage: user.fullName → "Justin Burrell"
 */
userSchema.virtual('fullName').get(function () {
    return `${this.firstName} ${this.lastName}`;
});

/**
 * hasGoogleLinked
 * Purpose: Quick check if user has connected their Google account
 * Usage: user.hasGoogleLinked → true/false
 * Used in: Frontend to show/hide Google Docs features, prompt linking
 */
userSchema.virtual('hasGoogleLinked').get(function () {
    return !!this.googleId;
});

module.exports = mongoose.model("User", userSchema);